setwd("~/GitHub/book-r-stan-bayesian-model-intro")
setwd("~/GitHub/book-r-stan-bayesian-model-intro/book-data")
# パッケージの読み込み
library(rstan)
library(bayesplot)
library(ggfortify)
library(gridExtra)
# 計算の高速化
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
# 正規ホワイトノイズ
set.seed(1)
wn <- rnorm(n = 100, mean = 0, sd = 1)
# 累積和をとる関数cumsumの説明
cumsum(c(1,3,2))
# ランダムウォーク
rw <- cumsum(wn)
# グラフを作る
p_wn_1 <- autoplot(ts(wn), main = "ホワイトノイズ")
p_rw_1 <- autoplot(ts(rw), main = "ランダムウォーク")
# 2つのグラフをまとめる
grid.arrange(p_wn_1, p_rw_1)
?grid.arrange
setwd("~/GitHub/Epidemic")
library(tidyverse)
#dashboard : Xu,et.al
remotes::install_github("GuangchuangYu/treeio")
remotes::install_github("GuangchuangYu/nCov2019")
library(treeio)
library(nCov2019)
wddat <- load_nCov2019()
jpdat <- wddat$global %>% filter(country == "Japan")
jpdat$time <- as.Date(jpdat$time)
jpdat.2 <- jpdat[1,]; id = 2;
for(i in 2:nrow(jpdat)) {
while(jpdat$time[i] - jpdat.2$time[id-1] != 1) {
jpdat.2[id,] <- jpdat.2[id-1,]
jpdat.2[id,]$time <- jpdat.2[id,]$time + 1
id = id + 1
}
jpdat.2[id,] <- jpdat[i,]
id = id + 1
}
jpdat <- jpdat.2; rm(i,id,jpdat.2)
jpdat <- jpdat %>%
mutate(confirm = c(NA, diff(cum_confirm, lag = 1))) %>%
mutate(heal = c(NA, diff(cum_heal, lag = 1))) %>%
mutate(dead = c(NA, diff(cum_dead, lag = 1)))
g_cum <- jpdat %>% mutate(remove = cum_heal + cum_dead) %>%
ggplot(aes(x = time)) +
geom_bar(aes(y = cum_confirm), stat = "identity", position = "dodge") +
geom_bar(aes(y = remove), colour = "red", fill = "red", stat = "identity", position = "dodge") +
scale_y_continuous(
limits = c(0, 10000)
) +
scale_x_date(date_labels = "%m/%d")
g <- jpdat %>% mutate(remove = heal + dead) %>%
ggplot(aes(x = time)) +
geom_line(aes(y = confirm)) +
geom_line(aes(y = remove), colour = "red") +
scale_y_continuous(
limits = c(0, 1000)
) +
scale_x_date(date_labels = "%m/%d")
grid.arrange(g_cum, g)
grid.arrange(g_cum, g); rm(g_cum, g)
# 複数のホワイトノイズ・ランダムウォーク系列
wn_mat <- matrix(nrow = 100, ncol = 20)
rw_mat <- matrix(nrow = 100, ncol = 20)
set.seed(1)
for(i in 1:20){
wn <- rnorm(n = 100, mean = 0, sd = 1)
wn_mat[,i] <- wn
rw_mat[,i] <- cumsum(wn)
}
# グラフを作る
p_wn_2 <- autoplot(ts(wn_mat), facets = F, main = "ホワイトノイズ") +
theme(legend.position = 'none') # 凡例を消す
p_rw_2 <- autoplot(ts(rw_mat), facets = F, main = "ランダムウォーク") +
theme(legend.position = 'none') # 凡例を消す
# 2つのグラフをまとめる
grid.arrange(p_wn_2, p_rw_2)
# データの読み込み
sales_df <- read.csv("5-2-1-sales-ts-1.csv")
# 日付をPOSIXct形式にする
sales_df$date <- as.POSIXct(sales_df$date)
setwd("~/GitHub/book-r-stan-bayesian-model-intro/book-data")
# データの読み込み
sales_df <- read.csv("5-2-1-sales-ts-1.csv")
# 日付をPOSIXct形式にする
sales_df$date <- as.POSIXct(sales_df$date)
# データの先頭行を表示
head(sales_df, n = 3)
# POSIXctの補足
POSIXct_time <- as.POSIXct("1970-01-01 00:00:05", tz="UTC")
as.numeric(POSIXct_time)
# データの準備
data_list <- list(
y = sales_df$sales,
T = nrow(sales_df)
)
str(data_list)
head(data_list)
# モデルの推定
local_level_stan <- stan(
file = "5-2-1-local-level.stan",
data = data_list,
seed = 1
)
# 収束の確認
mcmc_rhat(rhat(local_level_stan))
setwd("~/GitHub/Epidemic/stancode")
df <- read.csv("SIRmodel_data.csv", header = T, sep = ",")
T <- length(df$time)-1
data <- list(
T = T,
I_obs = df$I_obs[-1],
Y0 = c(1 - 1.53846E-08 - 1.53846E-08, 1.53846E-08, 1.53846E-08),
T0 = df$time[1],
TS = df$time[-1]
)
init_fun <- function() {
list(
beta = runif(1, 0.5, 1),
gamma = runif(1,0, 0.5),
sigma = runif(1,0, 0.01)
)
}
model_fit <- stan(
file = 'sirModel.stan',
chains = 0
)
fit <- stan(
fit = model_fit,
data = data,
init = init_fun,
pars = c('y_hat', 'beta', 'gamma', 'sigma'),
seed = 1234,
chains = 4,
iter = 2000,
warmup = 1000,
thin = 1,
)
print(
fit,
pars = c('beta', 'gamma', 'sigma'),
probs = c(0.025, 0.5, 0.975)
)
library(bayesplot)
mcmc_combo(fit, pars = c('beta', 'gamma', 'sigma'))
mcmc_rhat(rhat(fit))
setwd("~/GitHub/book-r-stan-bayesian-model-intro/book-data")
# 結果の表示
print(local_level_stan,
pars = c("s_w", "s_v","lp__"),
probs = c(0.025, 0.5, 0.975))
# 生成された乱数を格納
mcmc_sample <- rstan::extract(local_level_stan)
# Stanにおける状態を表す変数名
state_name <- "mu"
# 1時点目の状態の95%ベイズ信用区間と中央値を得る
quantile(mcmc_sample[[state_name]][, 1],
probs=c(0.025, 0.5, 0.975))
# すべての時点の状態の、95%ベイズ信用区間と中央値
result_df <- data.frame(t(apply(
X = mcmc_sample[[state_name]],# 実行対象となるデータ
MARGIN = 2,                   # 列を対象としてループ
FUN = quantile,               # 実行対象となる関数
probs=c(0.025, 0.5, 0.975)    # 上記関数に入れる引数
)))
# 列名の変更
colnames(result_df) <- c("lwr", "fit", "upr")
# 時間軸の追加
result_df$time <- sales_df$date
# 観測値の追加
result_df$obs <- sales_df$sales
# 図示のためのデータの確認
head(result_df, n = 3)
# 図示
ggplot(data = result_df, aes(x = time, y = obs)) +
labs(title="ローカルレベルモデルの推定結果") +
ylab("sales") +
geom_point(alpha = 0.6, size = 0.9) +
geom_line(aes(y = fit), size = 1.2) +
geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.3) +
scale_x_datetime(date_labels = "%Y年%m月")
plotSSM <- function(mcmc_sample, time_vec, obs_vec = NULL,
state_name, graph_title, y_label,
date_labels = "%Y年%m月"){
# 状態空間モデルを図示する関数
#
# Args:
#   mcmc_sample : MCMCサンプル
#   time_vec    : 時間軸(POSIXct)のベクトル
#   obs_vec     : (必要なら)観測値のベクトル
#   state_name  : 図示する状態の変数名
#   graph_title : グラフタイトル
#   y_label     : y軸のラベル
#   date_labels : 日付の書式
#
# Returns:
#   ggplot2により生成されたグラフ
# すべての時点の状態の、95%区間と中央値
result_df <- data.frame(t(apply(
X = mcmc_sample[[state_name]],
MARGIN = 2, quantile, probs = c(0.025, 0.5, 0.975)
)))
# 列名の変更
colnames(result_df) <- c("lwr", "fit", "upr")
# 時間軸の追加
result_df$time <- time_vec
# 観測値の追加
if(!is.null(obs_vec)){
result_df$obs <- obs_vec
}
# 図示
p <- ggplot(data = result_df, aes(x = time)) +
labs(title = graph_title) +
ylab(y_label) +
geom_line(aes(y = fit), size = 1.2) +
geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.3) +
scale_x_datetime(date_labels = date_labels)
# 観測値をグラフに追加
if(!is.null(obs_vec)){
p <- p + geom_point(alpha = 0.6, size = 0.9,
data = result_df, aes(x = time, y = obs))
}
# グラフを返す
return(p)
}
plotSSM(mcmc_sample = mcmc_sample, time_vec = sales_df$date,
obs_vec = sales_df$sales,
state_name = "mu", graph_title = "ローカルレベルモデルの推定結果",
y_label = "sales")
# 状態空間モデルの図示をする関数の読み込み
source("plotSSM.R", encoding="utf-8")
rm(list=ls())
# データの読み込み
sales_df_all <- read.csv("5-2-1-sales-ts-1.csv")
sales_df_all$date <- as.POSIXct(sales_df_all$date)
# データの準備
data_list_pred <- list(
T = nrow(sales_df_all),
y = sales_df_all$sales,
pred_term  = 20
)
head(data_list_pred)
# モデルの推定
local_level_pred <- stan(
file = "5-3-1-local-level-pred.stan",
data = data_list_pred,
seed = 1
)
# 参考：収束の確認
mcmc_rhat(rhat(local_level_pred))
# 参考：結果の表示
print(local_level_pred,
pars = c("s_w", "s_v","lp__"),
probs = c(0.025, 0.5, 0.975))
# 予測対象期間も含めた日付を用意
date_plot <- seq(
from = as.POSIXct("2010-01-01"),
by = "days",
len = 120)
# 参考
seq(from = as.POSIXct("2010-01-01"),
by = 60*60*24,
len = 120)
# 生成された乱数を格納
mcmc_sample_pred <- rstan::extract(local_level_pred)
# 予測結果の図示
plotSSM(mcmc_sample = mcmc_sample_pred,
time_vec = date_plot,
state_name = "mu_pred",
graph_title = "予測の結果",
y_label = "sales")
# 状態空間モデルの図示をする関数の読み込み
source("plotSSM.R", encoding="utf-8")
# 予測結果の図示
plotSSM(mcmc_sample = mcmc_sample_pred,
time_vec = date_plot,
state_name = "mu_pred",
graph_title = "予測の結果",
y_label = "sales")
# データの読み込み
sales_df_NA <- read.csv("5-3-1-sales-ts-1-NA.csv")
# 日付をPOSIXct形式にする
sales_df_NA$date <- as.POSIXct(sales_df_NA$date)
# 売り上げデータに一部欠損がある
head(sales_df_NA, n = 3)
# NAがある行を削除
sales_df_omit_NA <- na.omit(sales_df_NA)
sales_df_NA
head(sales_df_omit_NA, n = 3)
# データを取得した期間
nrow(sales_df_NA)
# 正しくデータが取得できた日数
nrow(sales_df_omit_NA)
# NAがどこにあるのかを判別
!is.na(sales_df_NA$sales)
# TRUEである要素番号の取得
which(c(TRUE, FALSE, TRUE))
# データがある行番号の取得
which(!is.na(sales_df_NA$sales))
# データの準備
data_list_interpolation <- list(
T       = nrow(sales_df_NA),
len_obs = nrow(sales_df_omit_NA),
y       = sales_df_omit_NA$sales,
obs_no  = which(!is.na(sales_df_NA$sales))
)
data_list_interpolation
# モデルの推定
local_level_interpolation <- stan(
file = "5-3-2-local-level-interpolation.stan",
data = data_list_interpolation,
seed = 1,
iter = 4000
)
# 参考：収束の確認
mcmc_rhat(rhat(local_level_interpolation))
# 参考：結果の表示
print(local_level_interpolation,
pars = c("s_w", "s_v","lp__"),
probs = c(0.025, 0.5, 0.975))
# 生成された乱数を格納
mcmc_sample_interpolation <- rstan::extract(
local_level_interpolation)
# 図示
plotSSM(mcmc_sample = mcmc_sample_interpolation,
time_vec = sales_df_all$date,
obs_vec = sales_df_all$sales,
state_name = "mu",
graph_title = "補間の結果",
y_label = "sales")
# モデルの推定
local_level_prediction_interval <- stan(
file = "5-3-3-local-level-interpolation-prediction-interval.stan",
data = data_list_interpolation,
seed = 1,
iter = 4000
)
# 参考：収束の確認
mcmc_rhat(rhat(local_level_prediction_interval))
# 参考：結果の表示
print(local_level_prediction_interval,
pars = c("s_w", "s_v","lp__"),
probs = c(0.025, 0.5, 0.975))
# 生成された乱数を格納
mcmc_sample_prediction_interval <- rstan::extract(
local_level_prediction_interval)
# 図示
plotSSM(mcmc_sample = mcmc_sample_prediction_interval,
time_vec = sales_df_all$date,
obs_vec = sales_df_all$sales,
state_name = "y_pred",
graph_title = "補間の結果:予測分布",
y_label = "sales")
